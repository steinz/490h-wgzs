\documentclass[11pt]{article}

\usepackage{amsmath, amssymb, amsthm}    	% need for subequations
\usepackage{fullpage} 	% without this, will have wide math-article-paper margins
\usepackage{graphicx}	% use to include graphics
\usepackage{verbatim}


%%%% Beginning of the Document %%%%
\begin{document}

\begin{center}
{\large CSE 490h -- Project 5: Application Writeup} \\
\textbf{Wayne Gerard - wayger} \\
\textbf{Zachary Stein - steinz} \\
March 14, 2011
\end{center}

\section{File setup}

For our application, we decided to partition files according to user names. Each username has the following three files associated with them:

1. A friendlist, named user.friends
2. A message file (containing messages for the user), named user.messages
3. A list of pending friend requests for this user, named user.requests

We presume that users will not need any more state than this. In a real system, it might be nice to separate messages based upon who sent them (so each user would have a user.friendname.messages file), and our system could easily support that with a few modifications. However, doing this would also introduce significant delays in both creating users and retrieving messages. In our system, which probably won't have a significant amount of traffic, the delays due to the necessary file creations would impact users to a greater extent than dealing with a single large file for all messages.

\section{File Access}

Using our distributed application from project 4, we decided to keep much of the same semantics. When a user logs in, the client simply requests to listen on the files that belong to that username. Due to the coordinator groups using paxos and paxos having persistent state, the files should exist forever as long as one coordinator comes online at some point.

\section{Privacy}

There's very little sense of privacy in our application. Any node can log in as any user and request any file they wish, including usernames that they did not create. This is obviously a privacy concern, and users should not expect any of their data to be private. Even if we did implement a password system, the very nature of our distributed system would mean that at the very least, coordinators would all have copies of files they're coordinating (which would include user information). 

We could implement both a password system and some method of file encryption, where only the user would have the appropriate key to decrypt the file contents. However, since privacy is not the focus of this assignment we decided that privacy was not a feature worth implementing. 

\section{Command Graph}

NOTE: Zach should talk about this here


\section{Logging in/out}

When a user logs in, they request to listen to all files associated with their user name. For example, if a user logged in as ``vincent'', then the node would request to listen to ``vincent.friends'', ``vincent.requests'', and ``vincent.messages''. Upon listening, the user will get the latest version of the log, and so any changes the user made previously should be reflected when they log in. 

When a user logs out, they simply cease to be ``vincent'' and so they cannot perform any actions as vincent. Technically the user will continue to receive updates on old files, but there is no way for them to take action as that user any longer. This also keeps the user up-to-date in the event that they wish to login again as ``vincent''.

We chose this approach because it meshed well with our previous project, and because it makes sense logically: there should be a separate file for friends, and for messages. The only file that might possibly be redundant is the requests file, which displays pending friend requests. However, doing this allows users to deal with friend requests at a convenient time without worrying about affecting other file states.

\section{Application command Semantics}

Users can perform the following commands:
\begin{verbatim}
User Administrative commands: createuser <username>, login <username>, logout
User commands:  requestfriend <friend>, post <message>, read, acceptfriend <friend>, rejectfriend <friend>,
\end{verbatim}

All of the commands users could previously perform exist as well, although for the purposes of this project users should not call them directly. To encourage that, we are not listing those commands explicitly in this writeup.

\section{HTML interface}

Our HTML "interface" is really just a wrapper around the file logs. The site is forcibly refreshed every few seconds via javascript, and the following information is displayed to the user:

\begin{verbatim}
-Friend list
-Pending friend requests
-Messages
\end{verbatim}

We decided to make this interface just to make the information more easily accessible. Rather than forcing the user to scroll up to discover their friend list, it is much easier to just view all the information in one page. The page refreshes every second in order to provide up-to-date information.

\section{Outstanding Issues}

There is a bug in the way our persistent storage in paxos works. Commands are keyed based on the proposal number, operation number (the line in the log), and the filename. When a new operation is learned, the command graph checks to see if the learned operation is something the command graph was waiting on to finish. This can result in the node erroneously assuming it finished a command when in fact it only learned about an old command.

For example, consider the following operations:
\begin{verbatim}
1. 1 create f1 (Proposal number = 1, operation number = 0)
2. 1 put f1 hello (Proposal number = 5, operation number = 1)
----Node 1 crashes----
3. 1 create f1 (Proposal number = 1, operation number = 0)
4. 1 put f1 world (Proposal number = 5, operation number = 1)
\end{verbatim}

What we would like to occur is for node 1 to learn about the first two operations (which it does), and then to do operation 4 as operation 5 with a new proposal number and operation number 2. However, when the node learns about operation number 2, it assumes that operation number 4 succeeded because the key values for the two operations are the same. 

One way around this would be to simply key the commands based upon the operation as well. However, in practice this exact situation is so unlikely that the additional overhead may not be worth losing a single operation. 

\end{document}
