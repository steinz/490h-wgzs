\documentclass[11pt]{article}

\usepackage{amsmath, amssymb, amsthm}    	% need for subequations
\usepackage{fullpage} 	% without this, will have wide math-article-paper margins
\usepackage{graphicx}	% use to include graphics
\usepackage{verbatim}


%%%% Beginning of the Document %%%%
\begin{document}

\begin{center}
{\large CSE 490h -- Project 5: Application Writeup} \\
\textbf{Wayne Gerard - wayger} \\
\textbf{Zachary Stein - steinz} \\
March 14, 2011
\end{center}

\section{Project Description}

Our application is a very simple version of facebook. Clients can create usernames, login and logout of existing usernames, manage their friendlist to a limited extent (users cannot remove friends currently), and can post messages to all of their friends (and read messages).


\section{File setup}

For our application, we decided to partition files according to user names. Each username has the following three files associated with them:

1. A friendlist, named user.friends
2. A message file (containing messages for the user), named user.messages
3. A list of pending friend requests for this user, named user.requests

We presume that users will not need any more state than this. In a real system, it might be nice to separate messages based upon who sent them (so each user would have a user.friendname.messages file), and our system could easily support that with a few modifications. However, doing this would also introduce significant delays in both creating users and retrieving messages. In our system, which probably won't have a significant amount of traffic, the delays due to the necessary file creations would impact users to a greater extent than dealing with a single large file for all messages.

\section{File Access}

Using our distributed application from project 4, we decided to keep much of the same semantics. When a user logs in, the client simply requests to listen on the files that belong to that username. Due to the coordinator groups using paxos and paxos having persistent state, the files should exist forever as long as one coordinator comes online at some point.

\section{Privacy}

There's very little sense of privacy in our application. Any node can log in as any user and request any file they wish, including usernames that they did not create. This is obviously a privacy concern, and users should not expect any of their data to be private. Even if we did implement a password system, the very nature of our distributed system would mean that at the very least, coordinators would all have copies of files they're coordinating (which would include user information). 

We could implement both a password system and some method of file encryption, where only the user would have the appropriate key to decrypt the file contents. However, since privacy is not the focus of this assignment we decided that privacy was not a feature worth implementing. 

\section{Command Graph}

NOTE: Zach should talk about this here


\section{Logging in/out}

When a user logs in, they request to listen to all files associated with their user name. For example, if a user logged in as ``vincent'', then the node would request to listen to ``vincent.friends'', ``vincent.requests'', and ``vincent.messages''. Upon listening, the user will get the latest version of the log, and so any changes the user made previously should be reflected when they log in. 

When a user logs out, they simply cease to be ``vincent'' and so they cannot perform any actions as vincent. Technically the user will continue to receive updates on old files, but there is no way for them to take action as that user any longer. This also keeps the user up-to-date in the event that they wish to login again as ``vincent''.

We chose this approach because it meshed well with our previous project, and because it makes sense logically: there should be a separate file for friends, and for messages. The only file that might possibly be redundant is the requests file, which displays pending friend requests. However, doing this allows users to deal with friend requests at a convenient time without worrying about affecting other file states.

\section{Application command Semantics}

Users can perform the following commands:
\begin{verbatim}
User Administrative commands: createuser <username>, login <username>, logout
User commands:  requestfriend <friend>, post <message>, read, acceptfriend <friend>, rejectfriend <friend>,
\end{verbatim}

All of the commands users could previously perform exist as well, although for the purposes of this project users should not call them directly. To encourage that, we are not listing those commands explicitly in this writeup.

\section{Command Graph Semantics}

The command graph currently aborts all queued commands if a command fails.  This means that if there are several queued commands, even outside of a transaction, a single failure can cause all pending commands to be aborted. 

In our view, this is expected and correct behavior. If a command fails for some reason, this means that the client does not have a current view of the file state, or the client erroneously entered a command. Rather than allow the client to continue on and possibly producing an unintended result, we believe that clients should just retry their commands and ensure that the result produced is the intended one.

\section{HTML interface}

Our HTML "interface" is really just a wrapper around the file logs. The site is forcibly refreshed every few seconds via javascript, and the following information is displayed to the user:

\begin{verbatim}
-Friend list
-Pending friend requests
-Messages
\end{verbatim}

We decided to make this interface just to make the information more easily accessible. Rather than forcing the user to scroll up to discover their friend list, it is much easier to just view all the information in one page. The page refreshes every second in order to provide up-to-date information.

\section{Project 6}

We are not describing our project 6 assignment here, because we have described it previously in our project 4 writeup. Our project 6 assignment, the distributed hash table, was closely interlinked with our project 4 assignment (because we use Paxos for every file operation in our distributed hash table file system). Because of that, we are not generating a separate writeup for project 6.

\end{document}
